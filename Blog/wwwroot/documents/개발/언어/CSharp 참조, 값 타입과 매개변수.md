---
Title: "C# 참조, 값 타입과 매개변수"
ThumbnailUri:
Tags:
  - CSharp
---

# 개요

블로그를 만드는 동안 C#을 꽤나 많이 사용했습니다. 원래는 C++만 사용하다 보니 헷갈리는 요소가 많아서, 몇 가지를 정리하려고 합니다.

## 가장 근본적인 차이: 참조(Reference)와 값(Value)

C#에서 변수를 다룰 때 가장 먼저 이해해야 할 것은 '참조 타입'과 '값 타입'의 차이입니다. 이것이 C++과 가장 다르게 느껴지는 지점입니다.

### 클래스: 참조를 기반으로 한 동작 (C++의 포인터처럼)

C#의 `class`는 **참조 타입**입니다. 클래스 변수는 객체 그 자체가 아니라, 힙 메모리에 생성된 객체를 가리키는 **참조(주소)**를 담고 있습니다. C++에 비유하자면, `class` 변수는 기본적으로 포인터처럼 취급된다고 생각하면 쉽습니다.

```csharp
class Person
{
	public string Name { get; set; } = string.Empty;
}

static void Main()
{
	Person a = new() { Name = "홍길동" };
	// 'a'가 가리키는 객체의 참조를 'b'에 복사합니다.
	Person b = a;

	// b를 통해 객체를 수정하면, 동일한 객체를 가리키는 a에도 영향이 갑니다.
	b.Name = "동길홍";

	// 둘 모두 "동길홍"을 출력합니다.
	Console.WriteLine(a.Name);
	Console.WriteLine(b.Name);
}
```

### 구조체: 값을 기반으로 한 동작 (C++의 일반 변수처럼)

반면 `struct`와 `int`, `bool` 같은 원시 타입들은 **값 타입**입니다. 변수에 데이터의 **완전한 복사본**이 저장됩니다. 이 동작 방식은 C++의 일반적인 변수 및 구조체와 완전히 동일합니다.

```csharp
struct Person
{
	public string Name { get; set; } = string.Empty;
}

static void Main()
{
	Person a = new() { Name = "홍길동" };
	// a의 데이터를 그대로 복사하여 새로운 Person 데이터 'b'를 만듭니다.
	Person b = a;

	// b는 a의 복사본이므로, b를 수정해도 a는 변하지 않습니다.
	b.Name = "동길홍";

	// "홍길동" 출력
	Console.WriteLine(a.Name);
	// "동길홍" 출력
	Console.WriteLine(b.Name);
}
```

## 메서드 호출

이러한 참조/값 타입의 특징은 메서드에 인자를 전달할 때 그대로 나타납니다.

- **클래스**를 매개변수로 넘기면, 객체를 가리키는 **참조의 복사본**이 전달됩니다. 따라서 메서드 안에서 해당 참조로 객체의 내용을 바꾸면 원본 객체도 변경됩니다.
- **구조체**를 매개변수로 넘기면, 데이터의 **완전한 복사본**이 전달됩니다. 메서드 안에서 매개변수를 아무리 바꿔도 원본에는 전혀 영향을 주지 않습니다.

### 전달 방식의 명시적 제어: `ref`, `in`, `ref readonly`, `out` 한정자

C#은 여기서 한 걸음 더 나아가, C++의 참조(`&`)나 포인터 참조(`*&`)처럼 데이터 전달 방식을 명시적으로 제어할 수 있는 키워드를 제공합니다. 바로 `ref`, `in`, `out` 입니다.

### `ref`: 양방향 참조 (읽기/쓰기)

`ref`는 매개변수를 **읽고 쓸 수 있는 완전한 참조**로 전달합니다. C++의 일반 참조(`&`)와 가장 유사하며, 메서드 내의 변경 사항이 원본 변수에 그대로 반영됩니다. `ref`로 인자를 넘기려면, 호출 전에 반드시 초기화되어 있어야 합니다.

```csharp
Type value = new();
// 초기화 없이 사용 시 에러가 발생합니다.
// Type value;
Method(ref value);
```

### `in`: 입력 전용 참조

`in`은 매개변수를 **읽기 전용 참조**로 전달합니다. 구조체와 클래스에서의 동작이 다르기 때문에 헷갈리기 쉽습니다.

- **구조체**  
   `in`은 C++의 상수 참조(`const&`)와 같은 개념입니다. 크기가 큰 구조체를 값 복사 없이 효율적으로 전달하면서, 원본을 수정할 수 없도록 보장합니다.  
   다만, C#에는 `const` 메서드 개념이 없기 때문에, 멤버를 수정하는 메서드 호출 시 불변성을 보장하기 위해 **방어적 복사**가 일어날 수 있습니다. 이 경우 참조의 장점이 사라지므로, 메서드를 `readonly`로 선언해 방어적 복사를 피하는 것이 좋습니다.
- **클래스**  
   클래스는 원래 참조 타입이므로, `in`은 참조 대상 객체의 불변성을 보장하지 않습니다. 단지 변수 자체의 **재할당**만 막습니다. 따라서 내부 멤버는 여전히 수정할 수 있습니다. 이 동작은 C++의 포인터 상수(`* const`)와 유사하며, 구조체와 달리 방어적 복사는 발생하지 않습니다.

### `ref readonly`: 입력 전용 참조

`ref readonly`는 `in`과 동작은 같지만, **호출 구문에서 `ref` 또는 `in`을 반드시 붙여야 하는 차이**가 있습니다. 두 키워드는 매개변수에 r-value를 전달하지 못하도록 합니다.

```csharp
Type value = new();

Method(in value); // 또는 Method(ref value);

// r-value 사용 시 오류 발생
// Method(defalut);
// Method(new Type());
```

### `out`: 출력 전용 참조

`out`은 메서드가 값을 **출력하는 용도**로만 사용되는 참조입니다. C++에서 포인터의 참조(`*&`)를 사용해 함수 내에서 객체를 생성하여 반환하는 패턴과 비슷합니다. `out` 매개변수는 초기화할 필요가 없으며, 대신 메서드는 반환되기 전에 **반드시 값을 할당**해야 함을 컴파일러가 강제합니다.

### 정리

간단히 표로 정리하면 다음과 같습니다.

| C# 코드                               | C++ 대응 개념                     | 설명                                                       |
| :---------------------------------- | :---------------------------- | :------------------------------------------------------- |
| `class name;`                       | `class* name;`                | 클래스는 참조 타입으로, C++의 포인터처럼 동작합니다.                          |
| `struct name;`                      | `struct name;`                | 구조체는 값 타입으로, C++의 일반 구조체와 동일하게 작동합니다.                    |
|                                     |                               |                                                          |
| `Method(class name);`               | `Method(class* name);`        | 클래스 객체를 전달하면 참조(주소)의 복사본이 전달됩니다.                         |
| `Method(struct name);`              | `Method(struct name);`        | 구조체를 전달하면 데이터의 완전한 복사본이 생성됩니다.                           |
|                                     |                               |                                                          |
| `Method(ref class name);`           | `Method(class*& name);`       | **\[양방향\]** 메서드 내에서 원본 변수가 참조하는 객체 자체를 변경할 수 있습니다.       |
| `Method(ref struct name);`          | `Method(struct& name);`       | **\[양방향\]** 값의 복사 없이 원본 구조체를 직접 참조하여 수정할 수 있습니다.         |
|                                     |                               |                                                          |
| `Method(in class name);`            | `Method(class* const name);`  | **\[읽기전용\]** 참조하는 객체를 변경할 순 없지만, 객체의 멤버는 수정 가능합니다.       |
| `Method(ref readonly class name);`  | `Method(class* const name);`  | `in`과 동일하지만 메서드 호출 시 매개변수 앞에 `in`, `ref` 키워드를 강제합니다.     |
| `Method(in struct name);`           | `Method(const struct& name);` | **\[읽기전용\]** 값의 복사 없이 참조하며, 메서드 내에서 수정이 불가능합니다.          |
| `Method(ref readonly struct name);` | `Method(const struct& name);` | `in`과 동일하지만 메서드 호출 시 매개변수 앞에 `in`, `ref` 키워드를 강제합니다.<br> |
|                                     |                               |                                                          |
| `Method(out class name);`           | `Method(class*& name);`       | **\[출력전용\]** 메서드 내에서 반드시 새로운 객체를 할당하여 전달해야 합니다.          |
| `Method(out struct name);`          | `Method(struct& name);`       | **\[출력전용\]** 메서드 내에서 반드시 값을 할당하여 전달해야 합니다.               |
